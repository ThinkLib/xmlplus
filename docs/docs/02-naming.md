{:#naming}
# 命名

## 一个示例

在探讨组件对象的命名之前，先看一个示例，后面的讲述主要围绕这个示例来展开。

```javascript
Index: {
   css: "#dog { color: red; }\
         #cat { color: blue; }\
         #animal { background: green; }",
   xml: "<div>\
             <h1 id='dog'>dog</h1>\
             <h1 id='cat'>cat</h1>\
         </div>",
   ali: { animal: "/div/h1" },
   fun: function ( sys, items, opts ) {
       console.log(sys.dog.text());
       console.log(sys.cat.text());
       sys.animal.call("css", "border", "1px solid black");
   }
}
```

此示例存在一个名称为Index的组件，它包含了四个组成部分。其中视图项包含要显示的对象，样式项包含了相关对象的样式，别名项是对集体对象的描述，函数项包含了相关的操作代码。

## 给个体元素命名

示例中，视图项包含三个`HTML`元素，其中两个都包含`id`属性，其属性值分别为`dog`和`cat`，我们把`dog`看作是第一个`h1`元素对象的名字，把`cat`看作是第二个`h1`元素对象的名字，而div则是一个未命名的元素对象。

所以，要给某一组件对象命名，只要给其相应的`xml`元素设定`id`属性值就可以了。下面给出一些命名方面的建议。

- 名称中应只包含字母、数字或下划线，且不能以数字开头
- 所取名字最好能做到见名思义
- 确保各个元素的命名在视图项中不是冲突的

其中头两条规定不是强制性的，但遵守它们有助于书写更好的代码。如果违反第三条规定，只有同名的最后一个对象才可以通过名称访问。

在程序运行时，视图项的任何已命名节点都会实例化为对象。对于那些没有命名的节点也是如此。虽然未命名的节点对象对于我们而言是不可见的，但我们完全有办法获得并使用它，在后面章节中将会看到这点是如何做到的。

## 给集体元素命名

众多的个体对象聚合在一起形成集体对象。从整体的角度来看，集体对象包含有别于个体对象的独有的性质，所以给集体对象命名有其必要性。下面来看如何给集体对象命名。

给集体对象命名时，首先需要知道怎样描述集体对象。集体对象的描述方式有很多种，可以是正则表达式或者`xpath`表达式，又或者是`css`选择器。对于用`XML`描述的对象集而言，使用专门配套的`xpath`表达式或者`css`选择器显然更好些。系统出于下面的理由，选择`xpath`表达式作为集体对象的描述。相对于`css`选择器，`xpath`表达式表达能力更为强大，比如对于文本对象，`css`选择器就没法选择出来。

示例中，注意别名项部分包含的`animal`选项，它的值是一个表示`div`元素子级的`xpath`表达式`/div/h1`，于是`animal`代表了`dog`和`cat`所组成的集体对象。集体对象类似于数组，它包含了表达式所描述的所有的个体对象，它有属于自己的接口属性。

## 在样式项中使用命名对象

在示例中，可以看到这样两行css字符串：

```css
#dog { color: red; }
#cat { color: blue; }
```

此处，首行引用了`dog`对象，并设置其字体颜色为红色；尾行引用了`cat`对象，并设置其字体颜色为蓝色。

从这里可以看出，在样式项中引用个体对象的方式是：以`#`开头，再追加上个体对象名。这与通常做网页开发时，对拥有`ID`属性的`html`元素的引用方式是一致的。

引用集体对象的方式与引用个体对象的方式是类似的，即以`#`开头，再追加上集体对象名。下面的样式将集体对象`animal`中的所有元素都加上了下划线。

```css
#animal { text-decoration: underline; } 
```

现在给视图项中的div元素对象也添加上名字属性，但删除组件的`ali`选项，如下代码所示。那么在样式项中就存在另一种对集体对象的引用方式，它引用的集体对象所包含的元素与上面的animal对象是一样的。

```javascript
Index: {
   css: "#animal div { background: green; }",
   xml: "<div id='animal'>\
             <h1 id='dog'>dog</h1>\
             <h1 id='cat'>cat</h1>\
         </div>"
} 
```

有时候，会存在同名的集体对象和个体对象`animal`。这种情况下，个体对象具有优先权，也就是个体对象的样式会覆盖集体对象的样式。当然，如果出现了这种情况，说明你的组件设计出问题了，你需要重新审视你工作。

## 在函数项中使用命名对象

下面的两行来自示例的函数项，`sys.dog`和`sys.cat`分别引用了已命名的`dog`对象和`cat`对象，并分别通过调用它们的接口函数`text`来获取对象所包含的文本。

```javascript
console.log(sys.dog.text());
console.log(sys.cat.text());
```

函数项中引用个体对象的方式：以`sys.`开头，再追加上个体对象名。当然，如果读者没有遵守前面对元素的命名约定，即元素名中包含非`JavaScript`标识符，那么就只能以类似访问数组元素的方式进行对象的引用。现在假设`sys`中包含名为`cat&`的个体元素，那么引用该元素方式就只能是：`sys["cat&"]`。

在函数项中引用集体对象的方式与引用个体对象的方式是一致的。集体对象有一个函数`call`，它的第一个参数是一个字符串，代表一个函数名，其后是所代表函数的实参列表。该函数会遍历集体对象所包含的所有个体对象，并调用指定的函数（如果存在的话）。

现在来看看示例中对集体对象的使用。

```javascript
sys.animal.call("css", "border", "1px solid black");
```

该语句会依次调用`dog`和`cat`对象的接口函数`css`，该函数以`border`和`1px solid black`作为函数实参列表。作用的结果是两个对象都被加上了一个像素的黑色边框。它的效果等同于下面两行语句。

```javascript
sys.dog.css("border", "1px solid black");
sys.cat.css("border", "1px solid black");
```

与前一节类似，有时候，会存在同名的集体对象和个体对象`animal`。这种情况下，个体对象将覆盖集体对象。也就是说，在函数项中是无法访问到集体对象的。

## 个体对象包含的两类接口

在示例中，读者一定还注意到了函数项部分包含的形参`items`。`items`与`sys`包含了同样多的个体对象与集体对象，并且名称完全相同。比如`sys`包含了`dog`对象，`items`也包含了`dog`对象，前者我们称之为系统对象，后者我们称之为组件自定义对象。

虽然系统对象与组件自定义对象是一对一的，但它们包含的函数接口却不尽相同。前面的`sys.dog`对象和`sys.cat`对象所调用的`text`函数即属于系统接口的一种。下面给出了系统对象包含的其它的部分接口函数名：

```javascript
on | off | trigger | append | before | remove | value…… 
```

这些接口函数由框架提供，它们是系统级别的，任何被实例化的对象都会有。系统接口提供了诸如组件对象之间通信或者组件的添加移除之类的功能。它们的使用方式后续章节会陆续讲述。

组件自定义对象所提供的接口取决于具体的组件，对于所有基组件对象，它们的自定义接口均为空。至于非基组件接口方面的内容后续会有章节详细讲述，这里暂且不表。

## 关于样式项中的符号`#`

为了了解样式项中符号`#`所代表的内容，先来看看框架最终由样式项生成的`css`代码以及最终由视图项生成的`html`代码（与实际的内容有略有出入，但大体一致）：

```css
.cadog { color: red; }
.cacat { color: blue; }
.caanimal { background: green; }
```
 
```html
<div class>
    <h1 class='cadog caanimal'>dog</h1>
    <h1 class='cacat caanimal'>cat</h1>
</div> 
```

观察元素的`class`属性并对比样式项内容，我们会发现符号`#`其实是一个通配符，这里它代表字符串`ca`，该字符串由系统内部自动生成，代表组件`Index`。框架在解析组件`Index`时，对样式项中所有的字符`#`都进行了替换，它把所有的字符`#`都替换成了字符串`ca`。从而，原始样式项和视图项中所包含的`id`属性，最终并非被映射成相应的`ID`值，而是被最终映射成的相应的类名。

## 组件的封闭性

现在假设在同一个应用中，我又定义了另一个组件，如下所示。也就是说，现在同一个应用中包含了两个不同的组件。

```javascript
Zoon: {
   css: "#dog { color: red; }\
         #cat { color: blue; }",
   xml: "<div>\
             <h1 id='dog'>dog</h1>\
             <h1 id='cat'>cat</h1>\
         </div>"
}
```

可以看出，该组件内部同样包含了名为`dog`和`cat`的对象。那么它们是否会和前面的定义和`dog`和`cat`冲突呢？这种担心是完全不必要的。因为在框架中，组件内部对象具有良好的封闭性，对于一个已实例化的组件对象而言，除了它开放的接口，你是无法访问其任何内部元素的。